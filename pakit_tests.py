#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Automated bot for testing recipes.
"""
from __future__ import absolute_import, print_function
import argparse
from argparse import RawDescriptionHelpFormatter as RawDescriptionHelp
import glob
import mmap
import os
import re
import sys

__version__ = '0.1.0'
TEMPLATE = """\"\"\"
Tests generated by {0}.
Do not edit this file, just rerun the program to regenerate.
\"\"\"
from __future__ import absolute_import, print_function
import os
import shutil
import pytest

import pakit.conf
import pakit.main
import pakit.recipe
import pakit.task


def delete_it(path):
    \"\"\"
    File or folder, it is deleted.

    Args:
        path: path to a file or dir
    \"\"\"
    try:
        shutil.rmtree(path)
    except OSError:
        try:
            os.remove(path)
        except OSError:
            pass


@pytest.fixture(scope='session', autouse=True)
def setup_test_bed(request):
    \"\"\"
    Fixture sets up the testing environment for pakit as a whole.

    Session scope, executes before all tests.
    \"\"\"
    def env_teardown():
        \"\"\"
        Cleanup post test run.
        \"\"\"
        delete_it(os.path.dirname(pakit.conf.CONFIG.path_to('link')))

    request.addfinalizer(env_teardown)

    root = os.getcwd()
    while not os.path.exists(os.path.join(root, '.travis.yml')):
        root = os.path.dirname(root)

    args = pakit.main.create_args_parser().parse_args(['available'])
    args.conf = os.path.join(root, 'tests', 'pakit.yml')
    pakit.main.global_init(args.conf)


class BaseRecipeTest(object):
    def setup(self):
        name = self.__class__.__name__.replace('Test_', '')
        self.recipe = pakit.recipe.RDB.get(name)

    def teardown(self):
        for leaf in ['prefix', 'source', 'link']:
            path = pakit.conf.CONFIG.path_to(leaf)
            delete_it(path)
            try:
                os.makedirs(path)
            except OSError:
                pass
        if self.recipe.name in pakit.conf.IDB:
            pakit.conf.IDB.remove(self.recipe.name)
""".format(os.path.basename(__file__)[0:-3])


def create_args_parser():
    """
    Create the program argument parser.

    Returns:
        An argparse parser object.
    """
    prog_name = os.path.basename(os.path.dirname(sys.argv[0]))
    mesg = """
    This script will (re)generate tests for recipes.
    It will OVERWRITE existing tests.
    """
    mesg = mesg[0:-5]
    parser = argparse.ArgumentParser(prog=prog_name, description=mesg,
                                     formatter_class=RawDescriptionHelp)
    parser.add_argument('-v', '--version', action='version',
                        version='pakit_tests {0}'.format(__version__))
    parser.add_argument('recipes_root', help='the folder containing recipes')
    parser.add_argument('output', nargs='?', default='tests/test_recipes.py',
                        help="""relative path from recipes root to test file,
                        default: tests/test_recipes.py""")

    return parser


def extract_repo_names(text):
    """
    Given a string, extract all keys from the string.

    Returns:
        List of keys in the string.
    """
    matcher = re.compile(r'\'(\w+)\':')
    results = [matched.group(1) for matched in matcher.finditer(text)]
    return results


def format_lines(recipes):
    """
    Transform the dictionary to lines to write.

    Returns:
        Lines to write to test file.
    """
    lines = []
    class_line = '\nclass Test_{0}(BaseRecipeTest):'
    repo_lines = """    def test_{0}(self):
        self.recipe.repo = '{0}'
        pakit.task.InstallTask(self.recipe).run()
"""

    for recipe in sorted(recipes):
        repo_name = recipes[recipe]
        lines.append(class_line.format(recipe))
        for repo_name in recipes[recipe]:
            lines.extend(repo_lines.format(repo_name).split('\n'))

    return lines[0:-1]


def scan_recipes(recipe_d):
    """
    Scan the recipe directory and return relevant data.
    """
    data = {}
    matcher = re.compile(r'class\s+\S+\(Recipe\)')
    candidates = [fname for fname in glob.glob(os.path.join(recipe_d, '*.py'))]

    for fname in candidates:
        short_name = os.path.basename(fname)[0:-3]
        with open(fname, 'r+') as fin:
            text = mmap.mmap(fin.fileno(), 0)
        if matcher.search(text) is not None:
            data[short_name] = extract_repo_names(text)

    return data


def write_file(root, test_file):
    """
    Write the test file as requested.
    """
    try:
        os.makedirs(os.path.dirname(test_file))
    except OSError:
        pass

    lines = TEMPLATE + '\n'.join(format_lines(scan_recipes(root)))
    with open(test_file, 'w') as fout:
        fout.write(lines)


def main(argv=None):
    """
    The main entry point for this program.

    Args:
        argv: A list of program options, if None use sys.argv.
    """
    if argv is None:
        argv = sys.argv

    parser = create_args_parser()
    args = parser.parse_args(argv[1:])

    root = os.path.abspath(args.recipes_root)
    if os.path.isabs(args.output):
        test_file = os.path.join(root, args.output)
    else:
        test_file = os.path.join(root, args.output)

    print('Scanning recipes under: ' + root)
    print('Writing tests to: ' + test_file)
    write_file(root, test_file)


if __name__ == "__main__":
    main()  # pragma: no cover
